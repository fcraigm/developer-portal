---
title: How to Develop and Test Locally
---

import OperationLink from "@site/src/components/OperationLink";
import SchemaWithExample from "../../../src/components/openapi/SchemaWithExample";

There is no way to start the mStudio public API locally.
This makes the local development of extensions challenging if the extension heavily integrates with the mStudio.
However, there are ways to assist the local extension development besides mocking the mStudio API, which might be difficult without deep knowledge of the API.
We will explore these in the rest of this page.

## Authenticated Domain Actions

The easiest way to effectively test the interaction of your business logic and the mStudio is to use the mStudio public API directly.
It is usually necessary to authenticate against the API.

### ...via a Personal API Token

It is a good idea to use your personal API token during the early development of your extension, while you evaluate your business idea and work on a proof of concept.
You can use this token for local development.
However, it is important that you **do not check in API tokens into version control systems** like Git.

For more information about obtaining an API token, see [obtaining an API token](../../../api/intro#obtaining-an-api-token).

### ...via Extension Instance Secret Rotation

Rotating the extension instance secret is another possibility for using the mStudio public API authenticated without implementing the authentication methods intended for extensions.
For this, you can use the <OperationLink operation="contributor-rotate-secret-for-extension-instance" /> operation.
The mStudio returns the new extension secret in the response and transfers it to the extension per webhook.
We recommend you store the obtained secret securely, similar to personal API tokens.
In the future, you can use this secret to obtain access tokens, as described in [authenticating with the extension instance secret](../../reference/api#authenticating-with-the-extension-instance-secret).
When using this route, the mStudio executes the webhook call synchronously.
If the webhook call fails, it is not sent again.
Also, the new secret is not valid if the webhook call failes.
To test without a working webhook handler, you can add `"allowWebhookFailure": true` to the request body.
This way, the mStudio ignores failures of the webhook calls and the mStudio responds to the request with the new secret.

If you plan to implement the authentication using the extension instance secret later, this method is especially useful.
Additionally, you can test initialization processes executed after webhook calls with a working secret without creating a new extension instance in the mStudio for every attempt.

### ...mittels OAuth2

Wenn die Authentifizierung und Ausführung von Domain Actions über OAuth2 getestet werden soll,
empfiehlt es sich, im OAuth2-Client eine lokale Redirect URI einzurichten.
Dies kann entweder localhost oder eine Domain sein, für die ein lokaler Host-Eintrag existiert.
Es sollte darauf geachtet werden, dass bei Verwendung eines Host-Eintrags keine potenziell öffentlich auflösbare Domain verwendet wird,
die nicht unter der Kontrolle des Entwicklers steht, um Sicherheitsrisiken zu vermeiden.

## Testen der Lifecycle Webhooks

### ...mittels lokalem Development Server

Auf Github existiert das [marketplace-local-dev-server](https://github.com/mittwald/marketplace-local-dev-server)-Repository,
welches dafür gedacht ist, lokal Lifecycle Webhooks samt Verifizierung der Sender-Identität zu testen.

:::note

Zum aktuellen Zeitpunkt ist der Marktplatz und die Contribution noch nicht für die Allgemeinheit offen.
Um Zugriff auf das Repository zu erhalten, kontaktiere bitte deinen Ansprechpartner bei mittwald.

:::

Es enthält eine Docker-Compose-Konfiguration, die einen lokalen Server startet, der Lifecycle Webhooks versenden kann.
Dazu wird eine API angeboten, mit der Lifecycle Webhooks angefragt werden können.
Die Werte, die in den Webhooks enthalten sind, können dabei frei gewählt werden.
Falls Werte nicht gesetzt sind, werden sie zufällig generiert.

Wenn bspw. die Extension Instance ID selbst vergeben wird, können so auch ganze Lebenszyklen von Extension Instances simuliert werden,
indem für verschiedene Webhooks eine stabile Extension Instance ID verwendet wird.

### ...mittels Dry Run Webhooks

Mithilfe der <OperationLink operation="extension-dry-run-webhook" />-Operation können Lifecycle Webhooks auch über das mStudio Backend simuliert werden.
Dabei wird der angefragte Lifecycle Webhook an die an der Extension konfigurierten URL gesendet.
Dry Run Webhooks können nur für Extension Instances des Contributors ausgeführt werden.
Sie können genau wie beim lokalen Development Server mit beliebigen Werten gefüllt werden oder zufällige Werte enthalten.
Für eine Übersicht, welche Werte statisch gesetzt werden können, siehe in der verlinkten Operation.

Das Ergebnis samt Response Body, Headern und Status Code wird dabei als Antwort auf die Operation zurückgegeben.

:::caution
Um den Webhook als Dry Run erkennbar zu machen, wird dem Webhook der Query-Parameter `dry-run=true` hinzugefügt.
Es sollte darauf geachtet werden, dass in Produktivsystemen keine Webhooks mit diesem Parameter verarbeitet und persistiert werden,
da es sich um eine Simulation handelt und so die Daten inkonsistent werden könnten.
:::

Zu Dokumentationszwecken kann zusätzlich der `executing-user-id` Query-Parameter ausgewertet werden.
Dieser wird ebenfalls automatisch jedem Dry Run Webhook beigefügt.
Er enthält die ID des Benutzers, der den Dry Run Webhook ausgelöst hat.
